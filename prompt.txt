cek lagi callback dari xendit setelah pembayaran selesai masih tidak jalan atau status di order dan payment tidak berubah

callback xendit https://4gcrpfz6-3000.asse.devtunnels.ms/api/xendit-callback

// routes
router.post("/xendit-callback", controllers.xenditCallback);

//controller fe paymentCallback
const {
  sequelize,
  Order,
  Payment,
  OrderItem,
  TicketType
} = require("../../../models");
const ticketService = require("../../services/fe/ticket.service");

module.exports = {
  async xenditCallback(req, res) {
    const trx = await sequelize.transaction();

    try {
      if (req.headers["x-callback-token"] !== process.env.XENDIT_CALLBACK_TOKEN) {
        return res.status(401).json({ message: "Invalid token" });
      }

      const { id, status } = req.body;

      const payment = await Payment.findOne({
        where: { provider_transactions: id },
        transaction: trx,
        lock: trx.LOCK.UPDATE
      });

      if (!payment) return res.json({ success: true });

      // ANTI DOUBLE CALLBACK
      if (payment.status === "paid") {
        await trx.commit();
        return res.json({ success: true });
      }

      const order = await Order.findByPk(payment.order_id, {
        transaction: trx,
        lock: trx.LOCK.UPDATE
      });

      const items = await OrderItem.findAll({
        where: { order_id: order.id },
        transaction: trx
      });

      if (status === "PAID") {
        // finalize stock
        for (const item of items) {
          const tt = await TicketType.findByPk(item.ticket_type_id, {
            transaction: trx
          });

          tt.reserved_stock -= item.quantity;
          tt.ticket_sold += item.quantity;
          await tt.save({ transaction: trx });
        }

        await payment.update({ status: "paid", paid_at: new Date() }, { transaction: trx });
        await order.update({ status: "paid" }, { transaction: trx });

        await ticketService.generateTickets(order.id, trx);
      } else {
        // rollback stock
        for (const item of items) {
          const tt = await TicketType.findByPk(item.ticket_type_id, {
            transaction: trx
          });

          tt.reserved_stock -= item.quantity;
          await tt.save({ transaction: trx });
        }

        await payment.update({ status: "failed" }, { transaction: trx });
        await order.update({ status: "canceled" }, { transaction: trx });
      }

      await trx.commit();
      res.json({ success: true });

    } catch (err) {
      await trx.rollback();
      console.error(err);
      res.status(500).json({ message: "Callback error" });
    }
  }
};


//service ticket
const { Ticket, OrderItem, Event } = require("../../../models");
const crypto = require("crypto");

module.exports = {
  async generateTickets(orderId, transaction) {
    const items = await OrderItem.findAll({
      where: { order_id: orderId },
      transaction
    });

    for (const item of items) {
      const attendees = JSON.parse(item.attendees);

      for (const a of attendees) {
        await Ticket.create({
          order_id: orderId,
          ticket_type_id: item.ticket_type_id,
          ticket_code: crypto.randomBytes(6).toString("hex"),
          owner_name: a.full_name,
          owner_email: a.email,
          owner_phone: a.phone,
          type_identity: a.type_identity,
          no_identity: a.no_identity,
          status: "issued",
          issued_at: new Date()
        }, { transaction });
      }
    }
  }
};
